        -:    0:Source:molecule_requester.c
        -:    1:#include <stdio.h>
        -:    2:#include <stdlib.h>
        -:    3:#include <string.h>
        -:    4:#include <unistd.h>
        -:    5:#include <arpa/inet.h>
        -:    6:#include <netdb.h>
        -:    7:#include <sys/time.h>
        -:    8:#include <sys/select.h>
        -:    9:
        -:   10:#define BUF_SIZE 1024
        -:   11:
        4:   12:int main(int argc, char *argv[]) {
        4:   13:    if (argc != 3) {
        1:   14:        fprintf(stderr, "Usage: %s <server> <port>\n", argv[0]);
        1:   15:        exit(1);
        -:   16:    }
        3:   17:    char *server = argv[1];
        3:   18:    int port = atoi(argv[2]);
        -:   19:
        -:   20:    int sockfd;
        -:   21:    struct sockaddr_in serv_addr;
        -:   22:    struct hostent *he;
        -:   23:
        3:   24:    if ((he = gethostbyname(server)) == NULL) {
    #####:   25:        perror("gethostbyname"); exit(1);
        -:   26:    }
        3:   27:    if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
    #####:   28:        perror("socket"); exit(1);
        -:   29:    }
        3:   30:    memset(&serv_addr, 0, sizeof(serv_addr));
        3:   31:    serv_addr.sin_family = AF_INET;
        3:   32:    serv_addr.sin_port = htons(port);
        3:   33:    memcpy(&serv_addr.sin_addr, he->h_addr, he->h_length);
        -:   34:
        3:   35:    printf("Type UDP requests (e.g., DELIVER WATER 3), type EXIT to quit:\n");
        -:   36:    char buf[BUF_SIZE], reply[BUF_SIZE];
        8:   37:    while (1) {
       11:   38:        if (fgets(buf, sizeof(buf), stdin) == NULL)
        1:   39:            break;
        -:   40:        // בדיקה אם המשתמש הקליד EXIT (מתעלם מרווחים אחריה)
       10:   41:        if (strncmp(buf, "EXIT", 4) == 0) {
        1:   42:            printf("Exiting molecule_requester. Goodbye!\n");
        1:   43:            break;
        -:   44:        }
        9:   45:        ssize_t slen = sendto(sockfd, buf, strlen(buf), 0, (struct sockaddr*)&serv_addr, sizeof(serv_addr));
       9*:   46:        if (slen < 0) { perror("sendto"); continue; }
        -:   47:
        -:   48:        // המתנה לתשובה מהשרת עם timeout
        -:   49:        fd_set readfds;
      153:   50:        FD_ZERO(&readfds);
        9:   51:        FD_SET(sockfd, &readfds);
        -:   52:        struct timeval tv;
        9:   53:        tv.tv_sec = 3; // 3 שניות timeout
        9:   54:        tv.tv_usec = 0;
        9:   55:        int retval = select(sockfd+1, &readfds, NULL, NULL, &tv);
       9*:   56:        if (retval == -1) {
    #####:   57:            perror("select");
    #####:   58:            continue;
        9:   59:        } else if (retval == 0) {
        1:   60:            printf("No response from server (possibly due to SHUTDOWN). Exiting.\n");
        1:   61:            break;
        -:   62:        } else {
        -:   63:            struct sockaddr_in from_addr;
        8:   64:            socklen_t fromlen = sizeof(from_addr);
        8:   65:            ssize_t n = recvfrom(sockfd, reply, sizeof(reply)-1, 0, (struct sockaddr*)&from_addr, &fromlen);
       8*:   66:            if (n < 0) { perror("recvfrom"); continue; }
        8:   67:            reply[n] = 0;
        8:   68:            printf("Server: %s", reply);
        -:   69:        }
        -:   70:    }
        3:   71:    close(sockfd);
        3:   72:    return 0;
        -:   73:}
