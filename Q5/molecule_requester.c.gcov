        -:    0:Source:molecule_requester.c
        -:    1:#include <stdio.h>
        -:    2:#include <stdlib.h>
        -:    3:#include <string.h>
        -:    4:#include <unistd.h>
        -:    5:#include <arpa/inet.h>
        -:    6:#include <netdb.h>
        -:    7:#include <sys/un.h>
        -:    8:#include <getopt.h>
        -:    9:#include <sys/time.h>
        -:   10:#include <sys/select.h>
        -:   11:
        -:   12:#define BUF_SIZE 1024
        -:   13:
        9:   14:int main(int argc, char *argv[]) {
        9:   15:    char *host = NULL, *uds_path = NULL;
        9:   16:    int port = -1;
        -:   17:    int opt;
       18:   18:    while ((opt = getopt(argc, argv, "h:p:f:")) != -1) {
        9:   19:        switch(opt) {
        4:   20:            case 'h':
        4:   21:                host = strdup(optarg); break;
        3:   22:            case 'p':
        3:   23:                port = atoi(optarg); break;
        2:   24:            case 'f':
        2:   25:                uds_path = strdup(optarg); break;
        -:   26:        }
        -:   27:    }
        9:   28:    if (((host || port > 0) && uds_path) || (!uds_path && (host == NULL || port <= 0))) {
        4:   29:        fprintf(stderr, "Error: specify either -h <host> -p <port> (UDP) OR -f <UDS path> (UDS datagram)\n");
        4:   30:        exit(1);
        -:   31:    }
        -:   32:
        -:   33:    int sockfd;
        5:   34:    if (uds_path) {
        -:   35:        // UDS Datagram
        2:   36:        sockfd = socket(AF_UNIX, SOCK_DGRAM, 0);
       2*:   37:        if (sockfd < 0) { perror("socket"); exit(1); }
        -:   38:        struct sockaddr_un serv_addr, cli_addr;
        2:   39:        memset(&serv_addr, 0, sizeof(serv_addr));
        2:   40:        serv_addr.sun_family = AF_UNIX;
        2:   41:        strncpy(serv_addr.sun_path, uds_path, sizeof(serv_addr.sun_path)-1);
        -:   42:
        -:   43:        // נדרש bind לכתובת ייחודית ללקוח
        -:   44:        char client_sock[256];
        2:   45:        snprintf(client_sock, sizeof(client_sock), "/tmp/molecule_req_%d.sock", getpid());
        2:   46:        memset(&cli_addr, 0, sizeof(cli_addr));
        2:   47:        cli_addr.sun_family = AF_UNIX;
        2:   48:        strncpy(cli_addr.sun_path, client_sock, sizeof(cli_addr.sun_path)-1);
        2:   49:        unlink(client_sock);
        2:   50:        if (bind(sockfd, (struct sockaddr*)&cli_addr, sizeof(cli_addr)) < 0) {
    #####:   51:            perror("bind client UDS"); exit(1);
        -:   52:        }
        -:   53:
        2:   54:        printf("Type UDP requests (e.g., DELIVER WATER 3), type EXIT to quit:\n");
        -:   55:        char buf[BUF_SIZE], reply[BUF_SIZE];
    #####:   56:        while (1) {
        2:   57:            if (fgets(buf, sizeof(buf), stdin) == NULL)
    #####:   58:                break;
        2:   59:            if (strncmp(buf, "EXIT", 4) == 0) {
        2:   60:                printf("Exiting molecule_requester. Goodbye!\n");
        2:   61:                break;
        -:   62:            }
    #####:   63:            ssize_t slen = sendto(sockfd, buf, strlen(buf), 0, (struct sockaddr*)&serv_addr, sizeof(serv_addr));
    #####:   64:            if (slen < 0) { perror("sendto"); continue; }
        -:   65:
        -:   66:            // Timeout
        -:   67:            fd_set readfds;
    #####:   68:            FD_ZERO(&readfds);
    #####:   69:            FD_SET(sockfd, &readfds);
    #####:   70:            struct timeval tv = {3, 0};
    #####:   71:            int retval = select(sockfd+1, &readfds, NULL, NULL, &tv);
    #####:   72:            if (retval == -1) {
    #####:   73:                perror("select");
    #####:   74:                continue;
    #####:   75:            } else if (retval == 0) {
    #####:   76:                printf("No response from server (possibly due to SHUTDOWN). Exiting.\n");
    #####:   77:                break;
        -:   78:            } else {
        -:   79:                struct sockaddr_un from_addr;
    #####:   80:                socklen_t fromlen = sizeof(from_addr);
    #####:   81:                ssize_t n = recvfrom(sockfd, reply, sizeof(reply)-1, 0, (struct sockaddr*)&from_addr, &fromlen);
    #####:   82:                if (n < 0) { perror("recvfrom"); continue; }
    #####:   83:                reply[n] = 0;
    #####:   84:                printf("Server: %s", reply);
        -:   85:            }
        -:   86:        }
        2:   87:        close(sockfd);
        2:   88:        unlink(client_sock);
        2:   89:        return 0;
        -:   90:    } else {
        -:   91:        // UDP
        -:   92:        struct sockaddr_in serv_addr;
        -:   93:        struct hostent *he;
        3:   94:        if ((he = gethostbyname(host)) == NULL) {
        1:   95:            perror("gethostbyname"); exit(1);
        -:   96:        }
        2:   97:        if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
    #####:   98:            perror("socket"); exit(1);
        -:   99:        }
        2:  100:        memset(&serv_addr, 0, sizeof(serv_addr));
        2:  101:        serv_addr.sin_family = AF_INET;
        2:  102:        serv_addr.sin_port = htons(port);
        2:  103:        memcpy(&serv_addr.sin_addr, he->h_addr, he->h_length);
        -:  104:
        2:  105:        printf("Type UDP requests (e.g., DELIVER WATER 3), type EXIT to quit:\n");
        -:  106:        char buf[BUF_SIZE], reply[BUF_SIZE];
        9:  107:        while (1) {
       11:  108:            if (fgets(buf, sizeof(buf), stdin) == NULL)
    #####:  109:                break;
       11:  110:            if (strncmp(buf, "EXIT", 4) == 0) {
        1:  111:                printf("Exiting molecule_requester. Goodbye!\n");
        1:  112:                break;
        -:  113:            }
       10:  114:            ssize_t slen = sendto(sockfd, buf, strlen(buf), 0, (struct sockaddr*)&serv_addr, sizeof(serv_addr));
      10*:  115:            if (slen < 0) { perror("sendto"); continue; }
        -:  116:            fd_set readfds;
      170:  117:            FD_ZERO(&readfds);
       10:  118:            FD_SET(sockfd, &readfds);
       10:  119:            struct timeval tv = {3, 0};
       10:  120:            int retval = select(sockfd+1, &readfds, NULL, NULL, &tv);
      10*:  121:            if (retval == -1) {
    #####:  122:                perror("select");
    #####:  123:                continue;
       10:  124:            } else if (retval == 0) {
        1:  125:                printf("No response from server (possibly due to SHUTDOWN). Exiting.\n");
        1:  126:                break;
        -:  127:            } else {
        -:  128:                struct sockaddr_in from_addr;
        9:  129:                socklen_t fromlen = sizeof(from_addr);
        9:  130:                ssize_t n = recvfrom(sockfd, reply, sizeof(reply)-1, 0, (struct sockaddr*)&from_addr, &fromlen);
       9*:  131:                if (n < 0) { perror("recvfrom"); continue; }
        9:  132:                reply[n] = 0;
        9:  133:                printf("Server: %s", reply);
        -:  134:            }
        -:  135:        }
        2:  136:        close(sockfd);
        2:  137:        return 0;
        -:  138:    }
        -:  139:}
